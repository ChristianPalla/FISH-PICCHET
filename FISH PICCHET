import sys
import random
import time
import csv

# Aumentiamo la profondità di ricorsione per i calcoli complessi
sys.setrecursionlimit(5000)

class GaraManager:
    def __init__(self, n_concorrenti, m_settori, min_salto_imposto):
        self.n = n_concorrenti
        self.m = m_settori
        self.picchetti_per_settore = n_concorrenti // m_settori
        
        # Impostazioni Distanza
        self.target_min_salto = min_salto_imposto
        self.max_salto_limite = self.n // 2
        
        self.storia_visite = {i: set() for i in range(1, self.n + 1)}
        self.tabella_turni = [] 
        
    def ottieni_settore(self, p_idx):
        return p_idx // self.picchetti_per_settore

    def get_vicini_turno_precedente(self, dati_turno_prec):
        vietati = {i: set() for i in range(1, self.n + 1)}
        mappa_pos = {pos: cid for cid, pos in dati_turno_prec.items()}
        for pos in range(self.n):
            if pos in mappa_pos:
                curr_id = mappa_pos[pos]
                sx = (pos - 1 + self.n) % self.n
                dx = (pos + 1) % self.n
                if sx in mappa_pos: vietati[curr_id].add(mappa_pos[sx])
                if dx in mappa_pos: vietati[curr_id].add(mappa_pos[dx])
        return vietati

    def inizializza(self):
        posizioni = list(range(self.n))
        random.shuffle(posizioni)
        stato_iniziale = {}
        for i in range(1, self.n + 1):
            pos = posizioni.pop()
            stato_iniziale[i] = pos
            self.storia_visite[i].add(pos)
        self.tabella_turni.append({'turno': 0, 'dati': stato_iniziale})

    def _backtrack_solve(self, idx_conc, elenco_conc, assegnazioni_turno, occupati_turno, 
                         vicini_vietati, mappa_pos_corrente, 
                         min_salto_attuale, consenti_vicini):
        if idx_conc >= len(elenco_conc): return assegnazioni_turno

        cid = elenco_conc[idx_conc]
        dati_prev = self.tabella_turni[-1]['dati']
        pos_old = dati_prev[cid]
        sett_old = self.ottieni_settore(pos_old)

        range_salti = list(range(min_salto_attuale, self.max_salto_limite + 1))
        range_salti.sort(key=lambda x: x + random.uniform(0, 2.0))

        for salto in range_salti:
            pos_new = (pos_old + salto) % self.n
            if pos_new in occupati_turno: continue
            if pos_new in self.storia_visite[cid]: continue
            
            sett_new = self.ottieni_settore(pos_new)
            if sett_new == sett_old: continue 
            
            if not consenti_vicini:
                sx = (pos_new - 1 + self.n) % self.n
                dx = (pos_new + 1) % self.n
                mossa_ko = False
                if sx in mappa_pos_corrente and mappa_pos_corrente[sx] in vicini_vietati[cid]: mossa_ko = True
                if dx in mappa_pos_corrente and mappa_pos_corrente[dx] in vicini_vietati[cid]: mossa_ko = True
                if mossa_ko: continue

            occupati_turno.add(pos_new)
            assegnazioni_turno[cid] = pos_new
            mappa_pos_corrente[pos_new] = cid
            
            res = self._backtrack_solve(idx_conc + 1, elenco_conc, assegnazioni_turno, occupati_turno, 
                                        vicini_vietati, mappa_pos_corrente, 
                                        min_salto_attuale, consenti_vicini)
            if res: return res
            
            del assegnazioni_turno[cid]
            del mappa_pos_corrente[pos_new]
            occupati_turno.remove(pos_new)
        return None

    def calcola_turno(self, numero_turno):
        dati_prev = self.tabella_turni[-1]['dati']
        vicini_vietati = self.get_vicini_turno_precedente(dati_prev)
        
        fasi = [
            {"nome": "RIGIDA", "min_salto": self.target_min_salto, "allow_vicini": False, "retries": 15},
            {"nome": "FLESSIBILE", "min_salto": self.target_min_salto, "allow_vicini": True, "retries": 10},
            {"nome": "SOPRAVVIVENZA", "min_salto": 1, "allow_vicini": True, "retries": 10}
        ]

        for fase in fasi:
            for _ in range(fase['retries']):
                concorrenti = list(range(1, self.n + 1))
                random.shuffle(concorrenti)
                risultato = self._backtrack_solve(0, concorrenti, {}, set(), vicini_vietati, {}, fase['min_salto'], fase['allow_vicini'])
                if risultato:
                    if fase['nome'] != "RIGIDA":
                        print(f"   [AVVISO] T{numero_turno}: Soluzione trovata in modalità {fase['nome']}.")
                    for cid, pos in risultato.items(): self.storia_visite[cid].add(pos)
                    self.tabella_turni.append({'turno': numero_turno, 'dati': risultato})
                    return True
        return False

    def stampa_tabella_perfetta(self):
        """
        Versione corretta: elimina gli spazi manuali e usa solo padding.
        """
        turni_totali = len(self.tabella_turni) - 1
        
        # DEFINIZIONE LARGHEZZE (Modificabili)
        W_ID = 10       
        W_DATA = 20     
        
        # Caratteri Box-Drawing
        C_TL, C_TM, C_TR = '╔', '╦', '╗'
        C_BL, C_BM, C_BR = '╚', '╩', '╝'
        C_VL, C_VM, C_VR = '╠', '╬', '╣'
        C_V,  C_H        = '║', '═'
        
        # Helper per righe orizzontali
        def print_sep(left, mid, right, intersect):
            # Costruisce la riga sommando esattamente le lunghezze W_ID e W_DATA
            line = left + (C_H * W_ID)
            for _ in range(turni_totali + 1): 
                line += intersect + (C_H * W_DATA)
            line += right
            print(line)

        print("\n")
        
        # 1. BORDO SUPERIORE
        print_sep(C_TL, C_TM, C_TR, C_TM)
        
        # 2. INTESTAZIONE
        # Nota: usiamo f"{C_V}{text:^{Width}}" SENZA spazi tra V e text
        header = f"{C_V}{'CONC.':^{W_ID}}"
        header += f"{C_V}{'PARTENZA':^{W_DATA}}"
        for t in range(1, turni_totali + 1):
            header += f"{C_V}{f'TURNO {t}':^{W_DATA}}"
        header += C_V
        print(header)
        
        # 3. SEPARATORE
        print_sep(C_VL, C_VM, C_VR, C_VM)
        
        # 4. RIGHE DATI
        for cid in range(1, self.n + 1):
            # ID
            row = f"{C_V}{f'ID {cid}':^{W_ID}}"
            
            # Partenza
            pos0 = self.tabella_turni[0]['dati'][cid]
            sett0 = self.ottieni_settore(pos0) + 1
            txt_start = f"S{sett0}-P{pos0+1:02d}"
            row += f"{C_V}{txt_start:^{W_DATA}}"
            
            # Turni
            for t in range(1, turni_totali + 1):
                pos = self.tabella_turni[t]['dati'][cid]
                pos_prev = self.tabella_turni[t-1]['dati'][cid]
                sett = self.ottieni_settore(pos) + 1
                salto = (pos - pos_prev + self.n) % self.n
                
                simbolo = " *" if salto < self.target_min_salto else ""
                content = f"S{sett}-P{pos+1:02d} (+{salto}{simbolo})"
                
                row += f"{C_V}{content:^{W_DATA}}"
            
            row += C_V
            print(row)
        
        # 5. BORDO INFERIORE
        print_sep(C_BL, C_BM, C_BR, C_BM)
        print(f" LEGENDA: (*) = Salto ridotto per 'Sopravvivenza'. Minimo richiesto era +{self.target_min_salto}")

    def esporta_csv(self):
        try:
            filename = "gara_fixed.csv"
            with open(filename, 'w', newline='') as f:
                w = csv.writer(f, delimiter=';')
                h = ["ID", "Start"]
                for t in range(1, len(self.tabella_turni)): h.extend([f"Turno {t}", f"Salto {t}"])
                w.writerow(h)
                for cid in range(1, self.n + 1):
                    r = [f"ID {cid}"]
                    p0 = self.tabella_turni[0]['dati'][cid]
                    r.append(f"S{self.ottieni_settore(p0)+1}-P{p0+1}")
                    for t in range(1, len(self.tabella_turni)):
                        p = self.tabella_turni[t]['dati'][cid]
                        pp = self.tabella_turni[t-1]['dati'][cid]
                        salto = (p - pp + self.n) % self.n
                        r.append(f"S{self.ottieni_settore(p)+1}-P{p+1}")
                        r.append(salto)
                    w.writerow(r)
            print(f"\n[OK] CSV Salvato in: {filename}")
        except: pass

# --- CONFIGURAZIONE ---
N_CONCORRENTI = 12
M_SETTORI = 6
N_TURNI = 4
TARGET_MIN_SALTO = 3 

def main():
    print("\n" + "="*70)
    print(f"  GARA CON TABELLA ALLINEATA (FIXED)")
    print("="*70)
    
    mgr = GaraManager(N_CONCORRENTI, M_SETTORI, TARGET_MIN_SALTO)
    mgr.inizializza()
    
    start = time.time()
    for t in range(1, N_TURNI + 1):
        if not mgr.calcola_turno(t):
            print(f"\n[CRITICO] Impossibile risolvere Turno {t}.")
            break
            
    print(f"\nCalcolo finito in {time.time()-start:.2f}s")
    mgr.stampa_tabella_perfetta()
    mgr.esporta_csv()

if __name__ == "__main__":
    main()
